package ethtools

import (
	"fmt"
	"math/big"
	"net/url"
	"os"
	"sort"
	"strings"

	"github.com/jmoiron/sqlx"
	_ "github.com/lib/pq"
)

var schema = `
CREATE TABLE IF NOT EXISTS address (
    Address  text NOT NULL,
    Name     text NOT NULL,
    Type     text NOT NULL,
    Symbol   text NOT NULL,
    Decimals integer NOT NULL,

    PRIMARY KEY(address)
);

CREATE TABLE IF NOT EXISTS analysis (
    Id          int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

    Date        text NOT NULL,
    Hour        integer NOT NULL,
    Minute      integer NOT NULL,
    Sec         integer NOT NULL,
    DurationSec integer NOT NULL,

    StartBlockNumber    integer NOT NULL,
    StartBlockTimestamp integer NOT NULL,
    EndBlockNumber      integer NOT NULL,
    EndBlockTimestamp   integer NOT NULL,

    ValueTotalEth                    NUMERIC(24, 8) NOT NULL,
    NumBlocks                        integer NOT NULL,
    NumTransactions                  integer NOT NULL,
    NumTransactionsWithZeroValue     integer NOT NULL,
    NumTransactionsWithData          integer NOT NULL,
    NumTransactionsWithTokenTransfer integer NOT NULL,
    TotalAddresses                   integer NOT NULL
);

CREATE TABLE IF NOT EXISTS analysis_address_stat (
    Id          int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

    Analysis_id int REFERENCES analysis (id) NOT NULL,
    Address     text REFERENCES address (address) NOT NULL,

	NumTxSent          int NOT NULL,
	NumTxReceived      int NOT NULL,
	NumTxTokenTransfer int NOT NULL,
	ValueSentEth       NUMERIC(24, 8) NOT NULL,
	ValueReceivedEth   NUMERIC(24, 8) NOT NULL,
	TokensTransferred  NUMERIC(32, 0) NOT NULL,

    TokensTransferredInUnit  NUMERIC(48, 8) NOT NULL,
    TokensTransferredSymbol  text NOT NULL
);
`

type Config struct {
	User       string
	Password   string
	Host       string
	Name       string
	DisableTLS bool
}

func GetDevDbConfig() Config {
	return Config{
		User:       "user1",
		Password:   "password",
		Host:       "localhost:5432",
		Name:       "ethstats",
		DisableTLS: true,
	}
}

func GetProdDbConfig() Config {
	return Config{
		User:       os.Getenv("DB_USER"),
		Password:   os.Getenv("DB_PASS"),
		Host:       os.Getenv("DB_HOST"),
		Name:       os.Getenv("DB_NAME"),
		DisableTLS: len(os.Getenv("DB_DISABLE_TLS")) > 0,
	}
}

func OpenDatabase(cfg Config) *sqlx.DB {
	sslMode := "require"
	if cfg.DisableTLS {
		sslMode = "disable"
	}

	q := make(url.Values)
	q.Set("sslmode", sslMode)
	q.Set("timezone", "utc")

	u := url.URL{
		Scheme:   "postgres",
		User:     url.UserPassword(cfg.User, cfg.Password),
		Host:     cfg.Host,
		Path:     cfg.Name,
		RawQuery: q.Encode(),
	}

	db, err := sqlx.Connect("postgres", u.String())
	if err != nil {
		panic(err)
	}

	db.MustExec(schema)
	return db
}

func GetAddressFromDatabase(db *sqlx.DB, address string) (addr AddressDetail, found bool) {
	err := db.Get(&addr, "SELECT * FROM address WHERE address=$1", strings.ToLower(address))
	if err != nil {
		return addr, false
	}
	return addr, true
}

func AddAddressesFromJsonToDatabase(db *sqlx.DB) {
	addressMap := GetAddressDetailMap(DATASET_BOTH)

	for _, v := range addressMap {
		fmt.Printf("%s \t %-10v \t %-30v %s \t %d\n", v.Address, v.Type, v.Name, v.Symbol, v.Decimals)

		// Check if exists
		_, found := GetAddressFromDatabase(db, v.Address)
		if found {
			fmt.Println("- already in DB")
			continue
		}

		db.MustExec("INSERT INTO address (address, name, type, symbol, decimals) VALUES ($1, $2, $3, $4, $5)", strings.ToLower(v.Address), v.Name, v.Type, v.Symbol, v.Decimals)
	}
}

func AddAnalysisResultToDatabase(db *sqlx.DB, date string, hour int, minute int, sec int, durationSec int, result *AnalysisResult) {
	// Insert Analysis
	analysisId := 0
	db.QueryRow("INSERT INTO analysis (date, hour, minute, sec, durationsec, StartBlockNumber, StartBlockTimestamp, EndBlockNumber, EndBlockTimestamp, ValueTotalEth, NumBlocks, NumTransactions, NumTransactionsWithZeroValue, NumTransactionsWithData, NumTransactionsWithTokenTransfer, TotalAddresses) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16) RETURNING id",
		date, hour, minute, sec, durationSec, result.StartBlockNumber, result.StartBlockTimestamp, result.EndBlockNumber, result.EndBlockTimestamp, result.ValueTotalEth, result.NumBlocks, result.NumTransactions, result.NumTransactionsWithZeroValue, result.NumTransactionsWithData, result.NumTransactionsWithTokenTransfer, len(result.Addresses)).Scan(&analysisId)
	fmt.Println("Added analysis to db. ID:", analysisId)

	// Create addresses array for sorting
	_addresses := make([]AddressInfo, 0, len(result.Addresses))
	for _, k := range result.Addresses {
		_addresses = append(_addresses, *k)
	}

	addAddressAndStats := func(addr AddressInfo) {
		// TODO: If already in DB, but more infos in JSON then update in DB
		fmt.Println("+ stats:", addr)
		_, foundInDb := GetAddressFromDatabase(db, addr.Address)
		if !foundInDb {
			detail, foundInJson := AllAddressesFromJson[strings.ToLower(strings.ToLower(addr.Address))]
			if !foundInJson {
				detail = AddressDetail{Address: addr.Address}
			}
			// insert with full details
			db.MustExec("INSERT INTO address (address, name, type, symbol, decimals) VALUES ($1, $2, $3, $4, $5)", strings.ToLower(detail.Address), detail.Name, detail.Type, detail.Symbol, detail.Decimals)
		}

		// fmt.Println("x", addr.Address)
		valRecEth := WeiToEth(addr.ValueReceivedWei).Text('f', 2)
		valSentEth := WeiToEth(addr.ValueSentWei).Text('f', 2)
		tokensTransferredInUnit, tokenSymbol, _ := TokenAmountToUnit(addr.TokensTransferred, addr.Address)

		db.MustExec("INSERT INTO analysis_address_stat (analysis_id, address, numtxsent, numtxreceived, NumTxTokenTransfer, valuesenteth, valuereceivedeth, tokenstransferred, tokenstransferredinunit, tokenstransferredsymbol) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)",
			analysisId, strings.ToLower(addr.Address), addr.NumTxSent, addr.NumTxReceived, addr.NumTxTokenTransfer, valSentEth, valRecEth, addr.TokensTransferred.String(), tokensTransferredInUnit.Text('f', 8), tokenSymbol)
	}

	// addAddresses := func(addresses []AddressInfo, n int) {
	// 	for i := 0; i < n; i++ {
	// 		addr := addresses[i]
	// 		if addr.NumTxReceived > 0 {
	// 			addAddressAndStats(addr)
	// 		}
	// 	}
	// }

	// Sort by num-tx-received
	// sort.SliceStable(_addresses, func(i, j int) bool { return _addresses[i].NumTxReceived > _addresses[j].NumTxReceived })
	// addAddresses(_addresses, 10)

	// Sort by token-transfers
	numAddressesTokenTransfers := 100
	sort.SliceStable(_addresses, func(i, j int) bool { return _addresses[i].NumTxTokenTransfer > _addresses[j].NumTxTokenTransfer })
	for i := 0; i < len(_addresses) && i < numAddressesTokenTransfers; i++ {
		if _addresses[i].NumTxReceived > 0 {
			addAddressAndStats(_addresses[i])
		}
	}

	// Sort by value-received
	numAddressesValueReceived := 25
	sort.SliceStable(_addresses, func(i, j int) bool { return _addresses[i].ValueReceivedWei.Cmp(_addresses[j].ValueReceivedWei) == 1 })
	for i := 0; i < len(_addresses) && i < numAddressesValueReceived; i++ {
		if _addresses[i].ValueReceivedWei.Cmp(big.NewInt(0)) == 1 { // if valueReceived > 0
			addAddressAndStats(_addresses[i])
		}
	}

	// Sort by value-sent
	numAddressesValueSent := 25
	sort.SliceStable(_addresses, func(i, j int) bool { return _addresses[i].ValueSentWei.Cmp(_addresses[j].ValueSentWei) == 1 })
	for i := 0; i < len(_addresses) && i < numAddressesValueSent; i++ {
		if _addresses[i].ValueSentWei.Cmp(big.NewInt(0)) == 1 { // if valueSent > 0
			addAddressAndStats(_addresses[i])
		}
	}
}
